#2级节点 [[类]]

## 公有继承
```C++
class B : public A
```
**派生类** 只能通过 **基类** 的公有方法或受保护方法访问 **基类** 的私有变量。

## 保护变量
```C++
class A
{
protected:
	int a;
};
```
**派生类方法** 可以访问保护变量，但 **派生类对象** 不能访问保护变量。

## 初始化
```C++
B::B() : A() {}
```
要用[[成员初始化列表]]初始化基类。
创建的时候是：基类构造函数->派生类构造函数
删除的时候是：派生类析构函数->基类析构函数
删除的时候不用显式调用基类析构函数，编译器自动调用

## 兼容性
```C++
A* p_a = &b;
A& r_a =  b;
```
**基类** 指针和引用可以兼容 **派生类**，但只能调用 **基类** 方法，不能调用 **派生类** 方法，反之则不行。
```C++
A a(b);
a = b;
```
**派生类** 对象可以初始化 **基类** 对象，反之不行。
**派生类** 对象可以赋值给 **基类** 对象，反之不行。

## [[虚函数]]

## 静态绑定
编译时绑定函数名和代码块。

## 动态绑定
运行时绑定，比如虚函数，因为虚函数不容易在编译时确定调用哪个代码块。
动态绑定灵活一些，但也慢一些，而且占用内存多一些。

## 抽象基类
Abstract Base Class, ABC
有时，两个类有相同的地方，但不是像继承这样，**派生类** 包含 **基类**。这种情况需要用 ABC 表示它们相同的地方。
```C++
virtual void method() = 0;
```
纯虚函数声明后加 `= 0`，带有纯虚函数的类为 ABC。

带有纯虚函数的类无法创建对象，但可以创建指针。
创建 ABC 指针正是设计 ABC 的目的之一，这样一个类型的指针可以同时调用 **基类** 和 **派生类** 两个类型的对象。

## 私有继承
```C++
class B : private A
```
**基类** 中 `public` 和 `protected` 的下内容，在 **派生类** 中全部变为 `private`，也就是只能在 **派生类** 中访问，**派生类对象** 不能访问。

继承时，默认私有继承

## 保护继承
```C++
class B : protected A
```
**基类** 中 `public` 和 `protected` 的下内容，在 **派生类** 中全部变为 `protected`。

## using
```C++
class B : public A
{
public:
	using A::method();
}
```
让 **基类** 的方法变为 `public`

## 多继承
```C++
class B : virtual public A
class C : virtual public A
class D : public B, public C
```
为了防止 `D` 中有两个 `A` 类，`B` 和 `C` 在继承 `A` 时，需要使用 `virtual`。这样 `D` 中只有一个 `A`。

在初始化的时候，不能通过 `B` 或 `C` 初始化 `A`，要在 `D` 中显式初始化 `A`。
如果 `A` 非 `virtual`，则可以简介初始化。

可以看出来，这样比较复杂，所以最好不要共用 **基类**。

## [[类模板]]

## [[别名]]