```C++
class A
{
public:
	virtual void method();
};

class B : A
{
public:
	virtual void method();
};

A* p_a = &b;
p_a->method();
```
当 **基类** 的指针和引用关联 **派生类** 对象时，如果存在多态情况，则调用关联 **派生类** 的虚函数。
假如不定义 `virtual`，则调用指针和引用类型的函数。
语法上，`virtual` 只修饰 **基类** 方法就够了，但为了可读性会在 **基类** 和 **派生类** 中同时修饰。
`virtual` 只在声明时使用，定义时不用。
**派生类** 中某个重载函数用 `virtual` 修饰后，**基类** 中所有同名函数均对 **派生类** 隐藏，不可通过 **派生类对象** 调用。
```C++
void B::method() { A::method(); }
```
在 **派生类** 中，可以通过范围解析符号 `A::` 访问 **基类** 同名函数。
```C++
virtual ~A();
```
**基类** 析构函数需要用 `virtual` 修饰，不然 **派生类** 的新成员不会被删除。
而构造函数不存在虚函数一说。